---
title: 5.React性能优化
createTime: 2025/08/21 13:01:20
permalink: /article/hsankocz/
---


### 1.React的更新流程
props/state改变 ---> render函数重新执行 ---> 产生新的DOM树 ---> 新旧DOM树进行diff ---> 计算出差异进行更新 ---> 更新到真实的DOM  
可以加入唯一标识keys，可以提高性能

#### render优化
render函数有两个弊端：
1. 只要我调用了setState去修改数据，哪怕新的数据和原本的数据一摸一样，render函数也会重新执行一遍；
2. 父组件调用render的时候，所有用到的自组件的render函数也会重新执行，哪怕没有数据的改变。

这时候可以用生命周期方法shouldComponentUpdate进行性能优化，它有两个参数，参数一：==nextProps== 修改之后，最新的props属性，参数二：==nextState== 修改之后，最新的state属性。这样我们就能拿到新的值和旧的值进行对比来决定是否调用render方法，该方法返回值是一个boolean类型：
返回值为true，那么就需要调用render方法；返回值为false，那么久不需要调用render方法；

但实际开发中肯定不会这样写，所以React就有两个东西直接帮我们实现了这个效果。
- 对于类组件，我们可以用PureComponent代替Component
```jsx
  class xxx extend PureComponent{}
```
- 对于函数式组件，没有这个类可以继承，我们就可以memo包裹
```jsx
  const xxx = memo(function(){})
```

### React中ref获取DOM的三种方式
非必要情况下我们是不操作DOM的，但是如果管理焦点，集成第三方库等，我们需要获取DOM有三种方式：
1. 传入字符串嘛，这种方式不推荐，因为refs已经废弃掉了
```jsx
  this.refs.aaa
  <h2 ref='aaa'>{message}</h2>
```
2. 传入一个对象(官方推荐)
```jsx
  const titleRef = React.createRef()
  console.log(this.titleRef.current)
  <h2 ref={this.titleRef}>{message}</h2>
```
3. 传入一个函数,在函数里面可以拿到这个DOM，然后赋值给我们的变量
```jsx
  const titleEl = null
  console.log(this.titleEl)
  <h2 ref={e => this.titleEl = e}>{message}</h2>
```

### ref获取组件
- 获取类组件：
  直接使用ref的第二种方式：createRef，见上面
- 获取函数式组件：
  因为函数式组件没有例，我们直接获取ref是获取不到了，但是我们可以通过一个高阶函数forwardRef，来获取到这个组件里面的某个DOM元素
```jsx
HelloWorld:
  const HelloWorld = forwardRef(function(props,ref){
    return(
      <div>
        <h2 ref={ref}></h2>
      </div>
    )
  })
App:
  constructor(){
    super()
    this.titleRef = React.createRef()
  }
  getComponent(){
    console.log(this.titleRef.current)
  }
  <HelloWorld ref={this.titleRef} />
```