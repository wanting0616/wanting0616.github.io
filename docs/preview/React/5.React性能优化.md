---
title: 5.React性能优化
createTime: 2025/08/21 13:01:20
permalink: /article/hsankocz/
---


### 1.React的更新流程
props/state改变 ---> render函数重新执行 ---> 产生新的DOM树 ---> 新旧DOM树进行diff ---> 计算出差异进行更新 ---> 更新到真实的DOM  
可以加入唯一标识keys，可以提高性能

#### render优化
render函数有两个弊端：
1. 只要我调用了setState去修改数据，哪怕新的数据和原本的数据一摸一样，render函数也会重新执行一遍；
2. 父组件调用render的时候，所有用到的自组件的render函数也会重新执行，哪怕没有数据的改变。

这时候可以用生命周期方法shouldComponentUpdate进行性能优化，它有两个参数，参数一：==nextProps== 修改之后，最新的props属性，参数二：==nextState== 修改之后，最新的state属性。这样我们就能拿到新的值和旧的值进行对比来决定是否调用render方法，该方法返回值是一个boolean类型：
返回值为true，那么就需要调用render方法；返回值为false，那么久不需要调用render方法；

但实际开发中肯定不会这样写，所以React就有两个东西直接帮我们实现了这个效果。
- 对于类组件，我们可以用PureComponent代替Component
```jsx
  class xxx extend PureComponent{}
```
- 对于函数式组件，没有这个类可以继承，我们就可以memo包裹
```jsx
  const xxx = memo(function(){})
```

### React中ref获取DOM的三种方式
非必要情况下我们是不操作DOM的，但是如果管理焦点，集成第三方库等，我们需要获取DOM有三种方式：
1. 传入字符串嘛，这种方式不推荐，因为refs已经废弃掉了
```jsx
  this.refs.aaa
  <h2 ref='aaa'>{message}</h2>
```
2. 传入一个对象(官方推荐)
```jsx
  const titleRef = React.createRef()
  console.log(this.titleRef.current)
  <h2 ref={this.titleRef}>{message}</h2>
```
3. 传入一个函数,在函数里面可以拿到这个DOM，然后赋值给我们的变量
```jsx
  const titleEl = null
  console.log(this.titleEl)
  <h2 ref={e => this.titleEl = e}>{message}</h2>
```

### ref获取组件
- 获取类组件：
  直接使用ref的第二种方式：createRef，见上面
- 获取函数式组件：
  因为函数式组件没有例，我们直接获取ref是获取不到了，但是我们可以通过一个高阶函数forwardRef，来获取到这个组件里面的某个DOM元素
```jsx
HelloWorld:
  const HelloWorld = forwardRef(function(props,ref){
    return(
      <div>
        <h2 ref={ref}></h2>
      </div>
    )
  })
App:
  constructor(){
    super()
    this.titleRef = React.createRef()
  }
  getComponent(){
    console.log(this.titleRef.current)
  }
  <HelloWorld ref={this.titleRef} />
```

### 受控组件和非受控组件
  React中，表单的处理方式和普通DOM不一样。
  对于类似于input，textarea等元素，我们如果没有给他绑定value值，就是一个非受控组件，如果绑定了value，就是一个受控组件，这时候这个组件的值就可以被我们操作。想要操作受控组件只能通过this.setState去改变然后触发render引起页面改变。
```jsx
  // 非受控
  <input type="text" />
  // 受控
  <input type="text" value={this.state.username} onChange={e => this.changeInput(e)}/>
```

::: tip 提示
  当我们使用非受控组件form的时候，如果没有使这个组件变成受控状态，那这个form会有默认的action提交刷新行为，所以我们需要在form的提交事件中阻止事件的默认行为event.preventDefault()
::: tip

::: tip 提示
  关于不可变力量，防止听到这个词不知道这个是什么，所以做一个记录。就是当我们对state赋值的时候，因为setState是异步的，所以当我们要赋值的是一个数组或者对象。最好是将数组拷贝到一个新的数组然后在setState，而不是直接使用类似于this.state.xxx.push('xxx');this.setState({arr:this.state.xxx})。这样可能导致数组变了，但是页面没有反应，可能没办法触发render函数。就会导致很多问题。这就是state的不可变力量。
::: tip

