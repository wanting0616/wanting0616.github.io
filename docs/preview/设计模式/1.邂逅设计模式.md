---
title: 1.定义
createTime: 2025/07/29 22:30:38
permalink: /article/ahikmcx4/
---

### 1.观察者模式
观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。  
🌰：班主任发布一个作业，只要订阅了这个作业通知的所有人都能收到这个作业发布的通知

### 2.装饰器模式
装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许向一个现有对象添加新的功能，同时又不改变其结构。装饰器模式通过创建一系列装饰器类，这些装饰器类都实现了相同的接口，以透明的方式包装原始类。  
🌰：当买了一辆新车，但是没有导航，我们新增一个导航功能，是不会影响车本身的结构的

### 3.代理模式
代理模式（Proxy Pattern）是一种结构型设计模式，它充当其他对象的接口，以控制对这个对象的访问。代理模式主要用于在访问一个对象时引入一定程度的间接性，以便实现某些控制或附加功能。  
🌰：相当于想买车，但是没时间，所以找了一个代理商给他钱，让他去买

### 4.适配器模式
适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户端期望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以协同工作。  
🌰：相当于接口不适配，我们可以用一个转接头

### 5.单例模式
单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例。单例模式通常用于控制对唯一实例的访问，以便在系统中的多个部分之间共享该实例。  
🌰：比如你去买车，竞拍车，每次出价1块钱，200个人同时出价，但车只有一辆。

### 6.解释器模式
解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且设计了该语言的解释器，使得用户可以使用特定的解释器来解释给定的语言表达式。
🌰：比如我们的车，有一些特定的车辆配置，比如车型、引擎、颜色等等，用户提供一个车辆配置的字符串，然后我们来解析并构造车辆对象。

### 7.组合模式
组合模式（Composite Pattern）是一种结构型设计模式，旨在允许客户端以统一的方式处理单个对象和对象的组合。组合模式将对象组织成树形结构，使得客户端可以一致地处理单个对象和组合对象。
🌰：我们的车，有很多部件组成，比如轮胎、引擎、座位等等，每一个都是一个单独的叶子对象，而车辆本身就是容器的节点。
::: tip 提示
场景：适用于需要构建层次结构，统一处理单个对象和组合对象，支持开闭原则的场景。
:::

### 8.享元模式
享元模式（Flyweight Pattern）是一种结构型设计模式，旨在通过共享对象来减小内存使用或减少计算开销，特别是用于解决大量细粒度对象创建和管理的问题。
🌰：无法举例，总体而言，享元模式通过共享相同的对象，达到减小内存占用和减少对象创建和销毁次数的目的。

### 9.策略模式
策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，将每个算法封装起来，并使它们可以互换。策略模式允许客户端选择算法的实现方式，使得客户端和算法之间解耦。
🌰：导航的时候，路线有很多种选择，我可以选择高速还是国道。

### 10.状态模式
状态模式（State Pattern）是一种行为型设计模式，它允许对象在内部状态发生改变时改变其行为。状态模式主要解决的是当一个对象的行为取决于它的状态，并且在运行时可以根据状态改变其行为的情况。
🌰：当我们将门反锁，门就打不开，但是如果我们只是关上门，那门是可以在外面和里面都可以打开的。

### 11.原型模式
原型模式（Prototype Pattern）是一种创建型设计模式，它通过复制现有对象来创建新对象，而不是通过实例化类。原型模式的核心思想是基于已有的对象创建新的对象，从而避免了创建过程中的一些复杂逻辑。
🌰：相当于复制然后深拷贝

### 12.中介模式
中介模式（Mediator Pattern）是一种行为型设计模式，它通过一个中介对象来协调其他对象之间的交互。中介者模式的目标是减少对象之间的直接通信，将复杂的交互关系变得更加松散，从而提高系统的可维护性和可扩展性。
🌰：相当于聊天室的功能，聊天室其实就是一个中介。

### 13.责任链模式
责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它通过一系列处理者（处理对象）来逐步处理请求，直到请求被处理为止。每个处理者都包含了处理请求的逻辑，并且知道下一个处理者是谁。
🌰：相当于线上宕机要追责，会从上到下一路追责下来。

### 14.备忘录模式
备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象内部状态的情况下，捕获并保存对象的内部状态，以便将对象恢复到之前的状态。
🌰：比如有一个事情要去干，但是当下没空，怕忘记，就记录在备忘录里。

### 15.访问者模式
访问者模式（Visitor Pattern）是一种行为型设计模式，它在不改变被访问对象的前提下，定义了新的操作。访问者模式通过在被访问的对象中加入一个对外提供的接受访问者的接口，使得访问者可以访问到对象的内部状态。
🌰：相当于想买课，然后各种销售会上门推销。

### 16.模板模式
模板模式是一种行为型设计模式，它定义了一个实现模板的骨架，将一些步骤推迟到子类，模板模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
🌰：一辆车，开车的步骤是什么？开门、点火、起步，但是有的人可能还需要听歌，那么开音乐就放在钩子放里面，根据自己的喜爱来。


### 17.迭代器模式
迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法来顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。迭代器模式让我们能够访问一个聚合对象的元素，而不用关心这个对象的内部结构
🌰：比如有很多辆车，我们需要遍历，自定义遍历。

### 18.命令模式
命令模式是一种行为型设计模式，它将请求封装成一个对象，从而使得可以参数化客户端对象，队列化请求，以及支持可撤销的操作。
🌰：比如遥控器，按下指定的键就执行对应的操作。

### 19.桥接模式
桥接模式是一种结构型设计模式，用于将抽象部分和实现部分分离，使它们可以独立变化。桥接模式通过组合的方式，将抽象类和实现类分离，使得它们可以独立变化而不互相影响。
🌰：比如我的车需要改造，改造的选项有修改颜色、修改轮毂、修改尾翼等等，我可以选择一项，也可以拼接，但是如果选择修改轮毂，必须要修改汽车颜色。。

### 20.建造者模式
建造者模式是一种创建型设计模式，用于构建复杂对象，该模式将一个复杂对象的构建过程和它的表示进行分离，使得同样的构建过程可以创建不同的表示。通过使用构建模式，可以逐步构建一个复杂的对象，同时使得客户端不需要知道对象的内部构建细节。
🌰：比如我们的产品是一辆车，它有轮子、座椅、方向盘、车架等等组成，但轮子又是橡胶等等组成、椅子又有布、铁等等组成，方向盘又有七七八八的，我们如果要组成一辆车，那根本不需要关心这些布啊铁啊之类的，我们只需要根据安装说明书，去拼装出来就可以了是吧。

### 21.外观模式
外观模式（Facade Pattern）是一种结构型设计模式，旨在为复杂子系统提供一个简化的接口，从而使客户端代码更容易使用。
🌰：比如你有一辆宝马车，你最常见的就是启动和关闭，而汽车启动需要启动发动机、启动冷却系统、启动润滑系统，自动开启音乐让你听，关闭的时候，需要把以上系统全部关闭，然后关闭音乐等等。你启动汽车的时候，应该是一键启动吧，这些系统应该都不需要你独立的去启动吧。嗯，这就是外观模式，外观理解为启动按钮，子系统理解为发动机、冷却、润滑系统等等，客户端就是你的手指。

### 22.工厂模式
工厂模式：用于一个创建对象的接口，目的就是定一个用于创建对象的接口，但将实例化的过程延迟到子类中，就是由子类去决定实例化哪个对象，这样客户端代码不需要具体的实例是如何创建的，只需要使用工厂提供的接口即可获取所需要的对象。
🌰：你要去拥有一辆车，你不需要自己去造，你只需要去汽车经销商，根据车品牌名称，就可以知道车辆的信息。此时汽车经销商就是工厂。

### 23.抽象工厂模式
抽象工厂模式是一种创建型设计模式，提供一种接口，用于创建相关或依赖对象的家族，而不需要指定它们的具体类，抽象工厂模式通过引入抽象工厂和具体工厂的概念，以及抽象产品和具体产品的概念，使得系统可以支持多个产品族的创建。
🌰：还是去买车，工厂模式需要你自己输入车名，但是抽象工厂模式就不需要，你只需要选择具体的车就好了。