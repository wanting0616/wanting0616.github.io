---
title: 2.感知阶跃面试
createTime: 2025/09/14 10:57:33
permalink: /article/7d55bscl/
---
一面：
- img的src没有加载出来，不想要它显示在界面上怎么办，用css实现  
  答：给 img 添加 required 属性，加载失败时会触发 :invalid 状态，此时设置 display: none 隐藏。
  /* 图片加载失败时隐藏 */
  img:invalid {
    display: none;
  }

- 图片放在public，assets，和oss网上有什么差别？这些图片打包在服务器有什么差别  
  答：public目录存放公共静态资源目录，不经过打包处理，存放在这里的图片会被直接复制到打包后的 dist。优点：无需处理打包路径，适合动态加载；不占用打包时间。缺点：不会被构建工具（Webpack/Vite）优化（如压缩、格式转换）；若路径错误，打包时不会报错，需运行时才能发现。  assets目录，存放在里面的图片会被构建工具处理，进行压缩，格式转化，哈希命名最终输出到dist中。优点：自动优化图片；路径错误时打包阶段会报错，提前发现问题；哈希命名避免浏览器缓存问题。缺点：不适合动态拼接路径  oss云存储直接存储在云端，与项目分离。优点：减轻项目服务器压力，图片加载由云服务 + CDN 承担，速度更快。支持按需加载、动态处理（如 OSS 可配置自动生成缩略图）。避免图片占用项目打包体积，减小 dist 大小。缺点就是可见的额外成本和依赖网络环境。

- 一个网站的性能用什么衡量  

- box-sizing的属性，两个属性有什么差别  
  答：content-box，内容优先盒模型，元素的 width 和 height 仅包含内容区域（content），不包含边框（border）和内边距（padding）。当给一个div设置为content-box之后，他实际的宽高会包含width和padding和border的宽度。border-box，边框包含的盒模型，元素的 width 和 height 包含内容区域（content）、内边距（padding）和边框（border）。当设置为border-box之后，如果设置width，这时候设置了border和padding，会导致width的真实宽度被压缩变小。

- ws用的是什么

- try，catch，进入try的还会进入finally吗，内部是怎么实现的
  答：会。JavaScript 引擎对 try/catch/finally 的处理，如果try出错立即停止执行剩余代码，跳转到 catch 块。无论 try 是否出错、catch 是否执行，甚至 try/catch 中有 return/break/continue，都会先执行 finally 中的代码。引擎会在执行 return/break 前 “暂停”，先执行 finally，再继续完成跳转 / 返回操作。

- 父子组件的创建和销毁顺序是怎么样的  
  答：核心原则是：“先父后子创建，先子后父销毁”。  
  简化流程：创建：父 beforeCreate → 父 created → 父 beforeMount →子 beforeCreate → 子 created → 子 beforeMount → 子 mounted →父 mounted  
  销毁：父 beforeDestroy →子 beforeDestroy → 子 destroyed →父 destroyed

- 生命周期之外的另外的钩子函数  
  答：activated和deactivated。这两个组件是专门用于keep-alive包裹的组件的生命周期钩子，用于监听组件在 “激活” 和 “缓存” 状态之间的切换。keep-alive 是 Vue 内置的抽象组件，用于缓存包裹的组件实例，而不是在组件切换时销毁和重建。它能保存组件的状态，避免重复渲染。

- rem，em，vh，vw有什么区别  
  答：都是相对长度单位。rem参考基准是根元素html的font-size，浏览器 html 的 font-size 是 16px。em：当前元素自身的font-size，若当前元素没有设置font-size，可以继承父元素的font-size；vh：视口高度的1%；vw：视口宽度的1%。

- 强制缓存和协商缓存  
  答：这两种缓存的核心区别在于是否需要向服务器确认缓存有效性。强制缓存是指浏览器直接从本地缓存中读取资源，不向服务器发送请求，直到缓存过期。协商缓存是指浏览器每次请求资源时，都会向服务器发送请求，由服务器判断是否可以使用本地缓存。

- useEffect和useLayoutEffect有什么区别  
  答：都是处理副作用函数的hook，核心的区别就是执行时机不同。useEffect：“异步执行”，在浏览器渲染完成后触发，React 完成组件渲染（DOM 已更新并绘制到屏幕）后，异步执行 useEffect 的回调函数。不会阻塞浏览器的渲染过程，执行时用户已经能看到更新后的界面。useLayoutEffect：“同步执行”，在 DOM 更新后、浏览器渲染前触发
执行阶段：React 完成 DOM 更新后，同步执行 useLayoutEffect 的回调函数，阻塞浏览器渲染，直到回调完成。执行时 DOM 已更新但尚未绘制到屏幕，用户看不到中间状态。  
底层执行顺序对比：组件触发更新（如状态变化 → React 重新计算虚拟 DOM 并更新真实 DOM（DOM 已变，但未渲染到屏幕）→ 执行 useLayoutEffect 回调（同步，阻塞渲染）→ 浏览器将更新后的 DOM 渲染到屏幕（用户可见）→ 执行 useEffect 回调（异步，不阻塞渲染）。

- Promise.all和Promise.allSettled有什么区别  
  答：见面试小知识点。

- any unknown never的区别  
  答：any 表示任意类型，TypeScript 会完全关闭对该变量的类型校验。unknown：“类型安全的 any”，unknown具有只读性，不能直接调用属性 / 方法，也不能直接赋值给其他类型，必须通过类型断言（as） 或类型检查（typeof/instanceof） 确认类型后，才能正常使用。never：“不存在的类型”，函数抛出异常（throw）或进入无限循环（while(true)）时，返回类型为 never。

- canvas用过什么常用的api

- Tindwindcss是怎么在项目里面配置的

- 假如用的Tindwindcss，我想要一个div的宽度是具体的71px，要怎么写。
  答：w-0，表示0px，w-1表示0.25rem，w-full表示占据全部，w-[71px]表示具体的数值

- setup在生命周期里面是哪个生命周期  
  答：不是生命周期钩子，而是 Composition API 的入口，替代了 beforeCreate 和 created 的 “初始化逻辑” 职责。setup 是 Vue 3 组件 “初始化的起点”，比传统的 beforeCreate 更早执行。

- seo相关的话，用的比较多可能就是语义化标签，说说有什么语义化标签  
  答：header，footer，main，nav，section，h，p。